#!/usr/bin/env python3
"""
Convert extracted figure images to tables using OpenRouter API with Claude Opus 4.5 and Haiku 4.5.

This script reads figure metadata from a JSON file (generated by extract_figures_parallel.py)
and converts each figure image to structured CSV tables, then creates markdown files.

Workflow:
1. Convert image to CSV using Opus 4.5
2. Run sanity check with second Opus 4.5 instance
3. If disagreement, run third Opus 4.5 instance
4. Generate markdown file using Haiku 4.5 with figure and context

Usage:
    python convert_figures_to_tables.py <figures_dir> [--metadata-file figures_metadata.json] [--api-workers N]
    
Example:
    python convert_figures_to_tables.py downloads/ketamine-in-vitro-safety/figures --api-workers 5
"""
import os
import sys
import json
import base64
import argparse
import csv
from typing import List, Dict, Any, Optional
from concurrent.futures import ThreadPoolExecutor, as_completed

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False


OPUS_MODEL = "anthropic/claude-opus-4.5"
HAIKU_MODEL = "anthropic/claude-haiku-4.5"


def get_openrouter_api_key() -> str:
    """Get OpenRouter API key from environment."""
    api_key = os.environ.get('OPENROUTER_API_KEY')
    if not api_key:
        # Try loading from env files
        script_dir = os.path.dirname(__file__)
        env_files = ['.env', 'ssds.env']
        for env_file in env_files:
            env_path = os.path.join(script_dir, env_file)
            if os.path.exists(env_path):
                with open(env_path, 'r') as f:
                    for line in f:
                        if line.startswith('OPENROUTER_API_KEY='):
                            api_key = line.strip().split('=', 1)[1].strip('"\'')
                            if api_key:
                                break
            if api_key:
                break
    return api_key or ''


def json_table_to_csv(table_data: Dict[str, Any]) -> str:
    """Convert JSON table data to CSV string."""
    import io
    output = io.StringIO()
    writer = csv.writer(output)
    headers = table_data.get("headers", [])
    rows = table_data.get("rows", [])
    if headers:
        writer.writerow(headers)
    for row in rows:
        writer.writerow(row)
    return output.getvalue().strip()


def compare_csv_content(csv1: str, csv2: str) -> bool:
    """
    Compare two CSV strings to determine if they agree.
    Returns True if they are similar enough, False if they disagree significantly.
    """
    if csv1.strip() == csv2.strip():
        return True
    
    # Parse both CSVs
    try:
        reader1 = csv.reader(csv1.splitlines())
        reader2 = csv.reader(csv2.splitlines())
        rows1 = list(reader1)
        rows2 = list(reader2)
        
        # If row/column counts differ significantly, they disagree
        if abs(len(rows1) - len(rows2)) > max(len(rows1), len(rows2)) * 0.2:
            return False
        
        # If column counts differ, they disagree
        if rows1 and rows2:
            if abs(len(rows1[0]) - len(rows2[0])) > 0:
                return False
        
        # Check if content is substantially similar
        # Simple heuristic: if more than 30% of cells differ, they disagree
        if rows1 and rows2:
            min_rows = min(len(rows1), len(rows2))
            differences = 0
            total_cells = 0
            for i in range(min_rows):
                min_cols = min(len(rows1[i]), len(rows2[i]))
                total_cells += min_cols
                for j in range(min_cols):
                    if rows1[i][j].strip() != rows2[i][j].strip():
                        differences += 1
            
            if total_cells > 0:
                diff_ratio = differences / total_cells
                return diff_ratio < 0.3
        
        return True
    except Exception:
        # If parsing fails, do simple string comparison
        return csv1.strip() == csv2.strip()


class ImageToTableConverter:
    """Convert images to CSV tables using OpenRouter API."""
    
    OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions"
    
    def __init__(self, api_key: str, opus_model: str, haiku_model: str):
        self.api_key = api_key
        self.OPUS_MODEL = opus_model
        self.HAIKU_MODEL = haiku_model
    
    TABLE_JSON_SCHEMA = {
        "type": "json_schema",
        "json_schema": {
            "name": "table_data",
            "strict": True,
            "schema": {
                "type": "object",
                "properties": {
                    "headers": {"type": "array", "items": {"type": "string"}},
                    "rows": {"type": "array", "items": {"type": "array", "items": {"type": "string"}}}
                },
                "required": ["headers", "rows"],
                "additionalProperties": False
            }
        }
    }
    def _make_api_request(self, model: str, system_prompt: str, user_prompt: str, image_path: str, temperature: float = 0.1, response_format: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Make an API request with image."""
        if not HAS_REQUESTS:
            return {"error": "requests library not installed"}
        if not self.api_key:
            return {"error": "OPENROUTER_API_KEY not set"}
        # Read and encode the image
        with open(image_path, "rb") as f:
            image_data = f.read()
        # Determine MIME type
        ext = os.path.splitext(image_path)[1].lower()
        mime_types = {
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.jpeg': 'image/jpeg',
            '.gif': 'image/gif',
            '.webp': 'image/webp',
        }
        mime_type = mime_types.get(ext, 'image/png')
        # Encode to base64
        image_base64 = base64.b64encode(image_data).decode('utf-8')
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
        }
        payload = {
            "model": model,
            "messages": [
                {"role": "system", "content": system_prompt},
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:{mime_type};base64,{image_base64}"
                            }
                        },
                        {
                            "type": "text",
                            "text": user_prompt
                        }
                    ]
                }
            ],
            "max_tokens": 4096,
            "temperature": temperature,
        }
        if response_format:
            payload["response_format"] = response_format
        try:
            response = requests.post(
                self.OPENROUTER_URL,
                headers=headers,
                json=payload,
                timeout=120
            )
            response.raise_for_status()
            result = response.json()
            if "choices" in result and len(result["choices"]) > 0:
                content = result["choices"][0]["message"]["content"]
                return {
                    "success": True,
                    "content": content,
                    "model": model,
                    "usage": result.get("usage", {})
                }
            else:
                return {"error": "No response content", "raw": result}
        except requests.exceptions.RequestException as e:
            return {"error": f"API request failed: {str(e)}"}
        except json.JSONDecodeError as e:
            return {"error": f"Failed to parse API response: {str(e)}"}
    
    def convert_to_csv(self, image_path: str, context: str = "") -> Dict[str, Any]:
        """
        Convert an image to CSV using Claude Opus 4.5 with structured outputs.
        
        Args:
            image_path: Path to the image file
            context: Optional context about the figure
            
        Returns:
            Dictionary with the CSV content
        """
        system_prompt = """You are a data extraction tool that extracts tabular data from images.

Extract data from the image and return it as a structured table with headers and rows.

Guidelines:
- For graphs/charts: extract approximate values, include axes labels and units in headers
- For tables: transcribe accurately, preserve structure
- For non-tabular content: create a summary table with descriptive headers
- All values must be strings"""

        user_prompt = f"""Extract all tabular data from this image.

Context: {context if context else 'None'}

Return the data as a table with headers and rows."""

        result = self._make_api_request(self.OPUS_MODEL, system_prompt, user_prompt, image_path, temperature=0.1, response_format=self.TABLE_JSON_SCHEMA)
        if result.get('success'):
            try:
                table_data = json.loads(result['content'])
                csv_content = json_table_to_csv(table_data)
                result['content'] = csv_content
                result['raw_json'] = table_data
            except json.JSONDecodeError as e:
                result['error'] = f"Failed to parse structured output: {e}"
                result['success'] = False
        return result
    
    def sanity_check_csv(self, image_path: str, csv_content: str, context: str = "") -> Dict[str, Any]:
        """
        Run a sanity check on CSV content using a second Opus 4.5 instance with structured outputs.
        
        Args:
            image_path: Path to the image file
            csv_content: The CSV content to check
            context: Optional context about the figure
            
        Returns:
            Dictionary with the checked/updated CSV content
        """
        system_prompt = """You are a data validation tool that reviews extracted tabular data against source images.

Review the provided CSV against the image. Return the table data, correcting any errors if found.

All values must be strings."""

        user_prompt = f"""Review this extracted data against the image.

Context: {context if context else 'None'}

Current extracted data:
{csv_content}

If accurate, return the same data. If you find errors, return the corrected version."""

        result = self._make_api_request(self.OPUS_MODEL, system_prompt, user_prompt, image_path, temperature=0.1, response_format=self.TABLE_JSON_SCHEMA)
        if result.get('success'):
            try:
                table_data = json.loads(result['content'])
                csv_content = json_table_to_csv(table_data)
                result['content'] = csv_content
                result['raw_json'] = table_data
            except json.JSONDecodeError as e:
                result['error'] = f"Failed to parse structured output: {e}"
                result['success'] = False
        return result
    
    def generate_markdown(self, image_path: str, csv_content: str, context: str = "", pdf_basename: str = "", page: int = 0, image_filename: str = "") -> Dict[str, Any]:
        """
        Generate a markdown file with the figure and context using Haiku 4.5.
        
        Args:
            image_path: Path to the image file
            csv_content: The CSV content to include
            context: Context about the figure
            pdf_basename: Name of the source PDF
            page: Page number in the PDF
            image_filename: Filename of the image (for markdown reference)
            
        Returns:
            Dictionary with the markdown content
        """
        system_prompt = """You are an expert at creating comprehensive documentation for scientific figures.

Your task is to create a well-formatted markdown document that includes:
1. A clear title/heading for the figure
2. The figure image (referenced appropriately)
3. The extracted CSV data formatted as a markdown table
4. All relevant context to understand the figure
5. Any notes or observations about the data

Make the document clear, informative, and easy to understand."""

        user_prompt = f"""Create a comprehensive markdown document for this figure.

Source information:
- PDF: {pdf_basename if pdf_basename else 'Unknown'}
- Page: {page if page else 'Unknown'}
- Image file: {image_filename if image_filename else 'See figure below'}

Context about this figure:
{context if context else 'No additional context provided.'}

Extracted CSV data:
{csv_content}

Create a markdown document that includes:
1. A descriptive title
2. Reference to the figure image using markdown image syntax: ![Description]({image_filename})
3. The CSV data formatted as a markdown table
4. All relevant context and explanations
5. Any important notes about the data or figure

Format it as a complete, standalone markdown document."""

        return self._make_api_request(self.HAIKU_MODEL, system_prompt, user_prompt, image_path, temperature=0.3)


def convert_figure_to_table(
    fig: Dict[str, Any],
    converter: ImageToTableConverter,
    output_dir: str,
    pdf_basename: str = ""
) -> Dict[str, Any]:
    """Convert a single figure to CSV and then markdown (for parallel processing)."""
    print(f"Processing: {fig['filename']}")
    
    # Step 1: Convert to CSV using first Opus 4.5 instance
    print(f"  Step 1: Converting to CSV...")
    csv_result1 = converter.convert_to_csv(
        fig['image_path'],
        fig.get('context', '')
    )
    
    if not csv_result1.get('success'):
        print(f"  Error in initial CSV conversion: {csv_result1.get('error')}")
        fig['csv_result'] = csv_result1
        return fig
    
    csv_content1 = csv_result1['content'].strip()
    
    # Save first CSV
    csv_filename = fig['filename'].rsplit('.', 1)[0] + '_table.csv'
    csv_path = os.path.join(output_dir, csv_filename)
    with open(csv_path, 'w', encoding='utf-8', newline='') as f:
        f.write(csv_content1)
    print(f"  Saved initial CSV to: {csv_filename}")
    
    # Step 2: Sanity check with second Opus 4.5 instance
    print(f"  Step 2: Running sanity check...")
    csv_result2 = converter.sanity_check_csv(
        fig['image_path'],
        csv_content1,
        fig.get('context', '')
    )
    
    if not csv_result2.get('success'):
        print(f"  Error in sanity check: {csv_result2.get('error')}")
        csv_content_final = csv_content1
    else:
        csv_content2 = csv_result2['content'].strip()
        
        # Compare the two CSVs
        if compare_csv_content(csv_content1, csv_content2):
            print(f"  Sanity check: CSVs agree, using first version")
            csv_content_final = csv_content1
        else:
            print(f"  Sanity check: CSVs disagree, running third instance...")
            # Step 3: Run third Opus 4.5 instance if disagreement
            csv_result3 = converter.sanity_check_csv(
                fig['image_path'],
                csv_content2,
                fig.get('context', '')
            )
            
            if not csv_result3.get('success'):
                print(f"  Error in third instance: {csv_result3.get('error')}")
                csv_content_final = csv_content2
            else:
                csv_content3 = csv_result3['content'].strip()
                
                # Compare second and third
                if compare_csv_content(csv_content2, csv_content3):
                    print(f"  Third instance agrees with second, using second version")
                    csv_content_final = csv_content2
                else:
                    # Use the second version as it's the middle ground
                    print(f"  All three differ, using second version")
                    csv_content_final = csv_content2
    
    # Update CSV file with final version
    with open(csv_path, 'w', encoding='utf-8', newline='') as f:
        f.write(csv_content_final)
    print(f"  Final CSV saved to: {csv_filename}")
    
    # Step 4: Generate markdown using Haiku 4.5
    print(f"  Step 4: Generating markdown...")
    markdown_result = converter.generate_markdown(
        fig['image_path'],
        csv_content_final,
        fig.get('context', ''),
        pdf_basename,
        fig.get('page', 0),
        fig['filename']
    )
    
    # Save markdown file
    markdown_filename = fig['filename'].rsplit('.', 1)[0] + '_table.md'
    markdown_path = os.path.join(output_dir, markdown_filename)
    
    if markdown_result.get('success'):
        with open(markdown_path, 'w', encoding='utf-8') as f:
            f.write(markdown_result['content'])
        print(f"  Saved markdown to: {markdown_filename}")
    else:
        with open(markdown_path, 'w', encoding='utf-8') as f:
            f.write(f"# Table extracted from {fig['filename']}\n\n")
            if pdf_basename:
                f.write(f"Source: Page {fig['page']} of {pdf_basename}\n\n")
            f.write("---\n\n")
            f.write("## CSV Data\n\n")
            f.write("```csv\n")
            f.write(csv_content_final)
            f.write("\n```\n")
        print(f"  Error generating markdown, saved basic version: {markdown_result.get('error')}")
    
    # Return updated figure dict
    fig['csv_result'] = {
        'success': True,
        'csv_content': csv_content_final,
        'csv_path': csv_path
    }
    fig['markdown_result'] = markdown_result
    return fig


def main():
    parser = argparse.ArgumentParser(
        description='Convert extracted figure images to CSV tables and markdown using Claude Opus 4.5 and Haiku 4.5',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=__doc__
    )
    parser.add_argument('figures_dir', help='Directory containing extracted figures')
    parser.add_argument(
        '--metadata-file', '-m',
        default='figures_metadata.json',
        help='Name of the metadata JSON file (default: figures_metadata.json)'
    )
    parser.add_argument(
        '--api-workers', '-w',
        type=int,
        default=5,
        help='Maximum number of parallel API calls (default: 5)'
    )
    parser.add_argument(
        '--pdf-name', '-p',
        default='',
        help='Name of the source PDF file (for metadata)'
    )
    
    args = parser.parse_args()
    
    # Validate input
    if not os.path.exists(args.figures_dir):
        print(f"Error: Directory not found: {args.figures_dir}")
        sys.exit(1)
    
    metadata_path = os.path.join(args.figures_dir, args.metadata_file)
    if not os.path.exists(metadata_path):
        print(f"Error: Metadata file not found: {metadata_path}")
        print(f"Please run extract_figures_parallel.py first to generate the metadata file.")
        sys.exit(1)
    
    if not HAS_REQUESTS:
        print("Error: requests library required for API calls")
        print("Install it with: pip install requests")
        sys.exit(1)
    
    # Load figure metadata
    print(f"Loading metadata from: {metadata_path}")
    with open(metadata_path, 'r', encoding='utf-8') as f:
        figures = json.load(f)
    
    if not figures:
        print("No figures found in metadata file.")
        sys.exit(0)
    
    print(f"Found {len(figures)} figures to convert")
    
    # Get API key
    api_key = get_openrouter_api_key()
    if not api_key:
        print("Error: OPENROUTER_API_KEY not found in environment or .env file")
        print("Set it with: export OPENROUTER_API_KEY=your_key_here")
        sys.exit(1)
    
    # Convert figures to tables
    print("\n" + "="*60)
    print("CONVERTING IMAGES TO CSV AND MARKDOWN (PARALLELIZED)")
    print("="*60)
    
    converter = ImageToTableConverter(api_key, OPUS_MODEL, HAIKU_MODEL)
    pdf_basename = args.pdf_name or os.path.basename(args.figures_dir)
    
    # Convert all figures in parallel
    print(f"Using {args.api_workers} parallel API workers")
    
    with ThreadPoolExecutor(max_workers=args.api_workers) as executor:
        conversion_futures = {
            executor.submit(convert_figure_to_table, fig, converter, args.figures_dir, pdf_basename): fig['index']
            for fig in figures
        }
        
        for future in as_completed(conversion_futures):
            try:
                updated_fig = future.result()
                # Update the figure in the list
                fig_index = updated_fig['index']
                for i, fig in enumerate(figures):
                    if fig['index'] == fig_index:
                        figures[i] = updated_fig
                        break
            except Exception as e:
                fig_index = conversion_futures[future]
                print(f"  Error converting figure {fig_index}: {e}")
    
    # Update metadata with table results
    with open(metadata_path, "w", encoding="utf-8") as f:
        json.dump(figures, f, indent=2, ensure_ascii=False)
    print(f"\nUpdated metadata with table results")
    
    print("\n" + "="*60)
    print("CONVERSION COMPLETE")
    print("="*60)
    print(f"Converted {len(figures)} figures to CSV and markdown")
    print(f"Output directory: {args.figures_dir}")


if __name__ == '__main__':
    main()
